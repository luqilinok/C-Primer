ex11_01

vector是一种顺序容器，其中的元素都是按照“顺序”存储的，每个元素有唯一对应的位置编号，所有操作都是按照编号位置进行的；
map是一种关联容器，其中的元素都是按照“关键字-值”对来进行存储的，关键字值和元素数据建立了对应关系

ex11_02

list是双向链表，支持双向顺序访问，可以在元素的任意位置添加或删除元素，因此如果元素数目较大，或者元素总是频繁的进行添加或删除操作，则采用list比较适合；

vector是可变大小数组，支持随机访问，在尾部位置添加或删除元素速度很快，因此如果只是在末尾添加或删除元素，则采用vector容器比较好；

deque是双端队列，支持随机访问，在头尾位置添加或删除元素速度较快，因此如果经常需要在头/尾位置添加或删除元素则用deque；

map是一种关联容器，通过关联字-值对来进行索引，因此适合一些对象按它们的某个特征进行访问的情形，例如按名字查询学生信息；

set是关键字的简单集合，当需要保存特定的值集合--通常是满足/不满足某种要求的值集合，用set最方便

ex11_05

map是关联字-值对的集合，当需要查找给定值对应的数据时，应该使用map
set就是关键字的简单集合，当需要判定给定值是否存在时，应该使用set

ex11_06

list是一个双向链表，是一个顺序容器，是按照元素顺序（位置）来进行访问的，因此如果要顺序访问这些元素，或者要按照位置来访问元素，应该选用list；
set是关键字的简单集合，是一个关联容器，如果需要快速判定是否有元素等于给定值，应该使用set

ex11_08

set是一个关联容器，是通过关键字来进行查找元素的，因此忽略重复的元素可以用set，
而vector是一个顺序容器，如果想排除重复的元素，需要用到find进行查找，比较费时


ex11_10

有序容器要求关键字类型必须支持比较操作，因此map<vector<int>::iterator,int> m1是可以的，因为vector的迭代器支持比较操作
反之，map<list<int>::iterator,int> m2是不可以的，因为list是双向链表，不是连续存储的，所以不支持比较操作

ex11_11

因为使用decltype作用于某个函数的时候，它返回函数类型而非指针类型，所以要显示的加上*表明我们需要返回指针类型，所以不用decltype重新定义compare的写法为：typedef bool (*pf)(const Sales_data&lhs,const Sales_data &rhs);或者是using compareType = bool (*)(const Sales_data& lhs, const Sales_data& rhs)；

ex11_15

由题意定义出如下map：map<int,vector<int>>,所以，它的mapped_type是vector<int>,key_type是int，value_type是pair<const int,vector<int>>

ex11_16

解引用关联容器的迭代器，得到的是一个value_type的值的引用，因此，对map而言，得到的是一个pair<const key_type,mapped_type>类型的引用，它的first成员保存const关键字，second成员保存值，所以，通过迭代器只能改变second，不能改变first，所以将一个值赋予一个元素为：int
map<int,int> m,
auto it=m.begin();
it->second=0;

ex11_17

set的迭代器是const的，只允许访问set中的元素，而不能改变set；set的关键字也是const，只读不改，因此前两个调用试图将vector中的元素复制到set中，是非法的行为；

第三个和第四个迭代器是将c中的元素赋值个v，即将set中的元素赋值给vector，是合法的

，
ex11_18

因为当解引用一个关联容器迭代器时，会得到一个类型为容器的value_type的值的引用，对map而言，value_type是一个pair类型，所以本题中要求的求出map_it是pair<const string,size_t>对象的引用，所以map_it的类型是：
pair<const string,size_t>::iterator

ex11_19

这道练习题考察的是关联容器迭代器的问题，根据题目中的要求，应该写出如下代码：
using compareType=bool(*)(const Sales_data &lhs,const Sales_data &rhs);
multiset<Sales_data,compareType> bookstore(compareType);
multiset<Sales_data,compareType>::iterator c_it=bookstore.begin();

ex11_21

循环不断从标准输入中读取字符串，直到遇到文件结束或错误
每次读入一个单词，构造pair{word,0},通过insert操作插入到word_count中，insert返回一个pair，其first成员是一个迭代器，如果单词已经存在，则指向已经存在的元素，否则，指向新插入的元素
因此，.first会得到这个迭代器，指向word对应的元素，继续使用->second，可获得元素的值的引用，即单词的计数。如果单词是新的，则它的值就是0，若已存在，则值为之前出现的次数，对其进行递增操作，即完成将出现次数加1

ex11_22

对一个map进行insert操作时，元素的类型是pair，即参数类型是pair<string,vector<int>>
又因为insert返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert返回一个pair，first成员是一个迭代器，指向具有给定关键字的元素，second成员是一个bool值，指出元素是插入成功还是已经存在于容器中，所以返回类型pair如下：
   pair<map<string,vector<int>>::iterator,bool>

ex11_24

若m中已有关键字0，下标操作提取出其值，赋值语句将其值置为1
否则，因为map的insert操作会创建一个pair类型的对象，所以下标操作会创建一个pair<0,0>，然后进行赋值操作，将值置为1，所以此时m的值就是pair<0,1>

ex11_25

这道题是考察顺序容器和关联容器的不同：
对于m，"0"表示关键字"0",对于v，"0"表示"位置0"
对于vector来说，如果v中有不少于一个元素，那么下标位置0就是存在的，所以v[o]=1这段程序会将0位置的元素提取出来，将其赋值为1；如果v是空的，那么就不存在下标位置为0的元素，这段程序就是非法的；
对于map来说，map的元素是pair类型的，下标提取的不是元素，而是pair的第二个成员，即“值”，所以如果存在关键字为0，那么就将关键字提取出来，将其赋值为1；如果不存在关键字0，就创建一个pair<0,0>，将第二个元素提取出来，赋值为1

ex11_26

可以用map的key_type来进行下标操作，下标运算符返回的类型是mapped_type
举个例子：
map类型：map<string,int>
用来进行下标操作的类型：string
下标操作返回的类型:int

ex11_27

find只可以用来查找关键字在容器中的位置，count不管能查到到关键字，而且还能找到关键字出现的次数，因此：
如果只是需要找到关键字在容器中出现的位置，则应该使用find，如果还需要求出关键字在容器中出现的次数，那么应该使用count

ex11_28

map<string,vector<int>> m;
map<string vector<int>>::iterator iter;

ex11_29

根据定义，lower_bound返回第一个具有给定关键字的元素，upper_bound返回最后一个具有给定关键字的元素之后的位置
所以，如果给定的关键字不在容器中，则这两个操作返回一个关键字插入的正确的位置，该位置不影响关键字的排序，如果给定关键字比容器中所有关键字都大，则此位置是容器的尾后位置end

equal_range返回一个pair，其first成员等价于lower_bound返回的迭代器，second成员等价于upper_bound返回的迭代器，因此如果给定关键字不在关联容器中，那么这两个迭代器构成一个空的范围

ex11_30

equal_range返回一个pair，其first成员等价于lower_bound的返回结果，即容器中第一个具有给定关键字的元素，又因为解引用一个关联容器迭代器时，会得到一个类型为容器的value_type的引用，本题中是会得到一个map的value_type的引用，即一个pair，其first是元素的关键字，即给定的关键字，而second为关键字关联的值，在本例中，关键字是作者，关联的值为著作的题目，因此pos.first->second即获得给定作者的第一部著作的题目

ex11_34

find只是用来寻找关联容器中的元素，如果不存在给定关键字，那么find会返回关联容器的尾后迭代器，不会进行其他的操作；
而下标运算符不是这样：当用下标运算符操作关联容器时，如果给定关键字在关联容器中，那么和find的操作是类似的，但是如果给定关键字没有在关联容器中，那么下标会构造一个pair进行值初始化，将其插入到容器中，对于单词转换程序，这会把不存在的内容插入到输出文本中，不符合题意

ex11_35

当map中没有给定关键字时，insert操作与下标操作+赋值操作的效果类似，都是将关键字和值得pair添加到map中
但是当map中已有给定关键字，也就是新的转换规则和一条已有的规则转换同一个单词时，两者的行为是不同的，下标操作会获得具有该关键字的元素的值，并将新读入的值赋予它，即用新规则覆盖原有的规则；
但是insert操作遇到关键字已经存在的情况不会改变容器内容，而是返回一个值指出插入失败，因此，当规则文件中存在多条规则转换相同的单词时，下标+赋值的版本最终会用最后一条规则进行文本转换，而insert版本则会用第一条规则进行文本转换

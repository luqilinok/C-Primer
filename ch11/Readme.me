ex11_01

vector是一种顺序容器，其中的元素都是按照“顺序”存储的，每个元素有唯一对应的位置编号，所有操作都是按照编号位置进行的；
map是一种关联容器，其中的元素都是按照“关键字-值”对来进行存储的，关键字值和元素数据建立了对应关系

ex11_02

list是双向链表，支持双向顺序访问，可以在元素的任意位置添加或删除元素，因此如果元素数目较大，或者元素总是频繁的进行添加或删除操作，则采用list比较适合；

vector是可变大小数组，支持随机访问，在尾部位置添加或删除元素速度很快，因此如果只是在末尾添加或删除元素，则采用vector容器比较好；

deque是双端队列，支持随机访问，在头尾位置添加或删除元素速度较快，因此如果经常需要在头/尾位置添加或删除元素则用deque；

map是一种关联容器，通过关联字-值对来进行索引，因此适合一些对象按它们的某个特征进行访问的情形，例如按名字查询学生信息；

set是关键字的简单集合，当需要保存特定的值集合--通常是满足/不满足某种要求的值集合，用set最方便

ex11_05

map是关联字-值对的集合，当需要查找给定值对应的数据时，应该使用map
set就是关键字的简单集合，当需要判定给定值是否存在时，应该使用set

ex11_06

list是一个双向链表，是一个顺序容器，是按照元素顺序（位置）来进行访问的，因此如果要顺序访问这些元素，或者要按照位置来访问元素，应该选用list；
set是关键字的简单集合，是一个关联容器，如果需要快速判定是否有元素等于给定值，应该使用set

ex11_08

set是一个关联容器，是通过关键字来进行查找元素的，因此忽略重复的元素可以用set，
而vector是一个顺序容器，如果想排除重复的元素，需要用到find进行查找，比较费时


ex11_10

有序容器要求关键字类型必须支持比较操作，因此map<vector<int>::iterator,int> m1是可以的，因为vector的迭代器支持比较操作
反之，map<list<int>::iterator,int> m2是不可以的，因为list是双向链表，不是连续存储的，所以不支持比较操作

ex11_11

因为使用decltype作用于某个函数的时候，它返回函数类型而非指针类型，所以要显示的加上*表明我们需要返回指针类型，所以不用decltype重新定义compare的写法为：typedef bool (*pf)(const Sales_data&lhs,const Sales_data &rhs);或者是using compareType = bool (*)(const Sales_data& lhs, const Sales_data& rhs)；

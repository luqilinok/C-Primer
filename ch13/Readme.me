ex13_01

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数；
拷贝构造函数在以下几种情况下都会被使用：
1.拷贝初始化（用=定义变量）；
2.将一个对象作为实参传递给一个非引用类型的形参；
3.用花括号列表初始化一个数组中的元素或一个聚合类中的成员
4.初始化标准库容器或者调用其insert/push操作时，容器会对其元素进行拷贝初始化


ex13_02

这个声明是非法的，因为这条声明符合使用拷贝构造函数的第二种情况--将一个对象作为实参传递给一个非引用类型的形参，因此这个拷贝构造函数的参数应该是引用类型的，但是实际上这个参数是非引用类型的，所以是错误的，应该进行如下的修改：
Sales_data::Sales_data(Sales_data &rhs)

ex13_03

StrBlob只有一个成员函数，是shared_ptr<vector<string>> data,所以拷贝StrBlob时，根据“对类类型的成员，会使用其拷贝构造函数来进行拷贝”这一规则，会使用一个拷贝构造函数来拷贝StrBlob的成员，又因为StrBlob中的成员函数是智能指针shared_ptr，对其进行拷贝会使其引用计数加1；
StrBlobPtr有两个成员函数，分别是weak_ptr<vector<string>>和普通类型的，所以根据规则，对于weak_ptr<vector<string>>类型的用拷贝构造函数来对其进行拷贝，其引用计数不变1，curr是普通类型的，直接拷贝就可以了


ex13_04

拷贝初始化通常通过拷贝构造函数来实现，因此，如果下面的程序片段满足发生拷贝初始化的条件，则该片段使用了拷贝构造函数：
1.因为在函数调用的过程中，具有非引用类型的参数要进行拷贝初始化---本段程序中，Point foo_bar(Point arg)的参数不是引用类型的，因此进行拷贝初始化，使用了拷贝构造函数；
2.从一个返回类型为非引用类型的函数返回一个对象需要用拷贝初始化---因此return *head使用了拷贝构造函数；
3.将一个对象作为实参传递给一个非引用类型的形参需要用拷贝初始化---因此Point local=arg,*head=local进行了拷贝初始化，使用了拷贝构造函数
4.用花括号列表初始化一个数组中的元素要进行拷贝初始哈---Point pa[4]={local，*heap}进行了拷贝初始化，使用了拷贝构造函数，将local、*heap拷贝到数组中前两个元素

ex13_05
拷贝构造函数的定义应该是其第一个参数是自身类类型的引用，且大部分都是const的引用，所以应该
HasPtr::HasPtr(const HasPtr &hr)
{
	ps = new string(*hr.ps);
	i = hr.i;
}

ex13_06

拷贝赋值运算符，是一个名为operator=的函数，由返回类型和参数列表组成。
当需要对类的对象进行拷贝操作时，就会使用拷贝赋值运算符。
如果一个类没有定义自己的拷贝赋值运算符，编译器就会为其合成拷贝赋值运算符，完成赋值操作，但是对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值

ex13_07

这两个类都没有定义拷贝赋值运算符，因此编译器为它们定义了合成的拷贝赋值运算符，赋值一个StrBlob时，拷贝类中唯一的成员data，使用shared_ptr的拷贝赋值运算符来完成，因为对智能指针进行拷贝操作，其引用计数会加上1；
赋值一个StrBlobPtr时，类中的成员函数由智能指针weak_ptr和普通的成员curr，所以赋值weak_ptr时，其引用计数不变，赋值普通的成员函数curr时，直接进行内存复制


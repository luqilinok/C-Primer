ex16_01

当调用一个函数模板时，编译器会利用给定的函数实参来推断模板实参，用此实际实参代替模板参数来创建出一个新的“实例”，也就是一个真正可以调用的函数，这个过程称为实例化

ex16_03

在gcc-4.8.1中，对两个Sales_data对象调用compare函数模板，编译器会报告如下错误。原因是compare是用<运算符来比较两个对象的，需要类型T实现定义<运算符，但是Sales_data类没有定义<运算符，所以会报错
error:no match for 'operator<'(operand types are 'const Sales_data') and 'const Sales_data'

ex16_06

begin应返回数组首元素的指针，因此是return &a[0],end返回尾后指针，因此在begin上加上数组大小N即可，模板定义请看ex16_06.h

ex16_08

泛型编程的一个目标就是令算法是“通用的”，这样就能够适应不同的类型，所有标准库容器都定义了==和!=运算符，但是只有少量定义了<运算符，因此，尽量使用!=而不是<,可以减少算法适用容器的限制

ex16_09

函数模板是可以实例化出特定函数的模板，类模板是可以实例化出特定类的模板；
从形式上来说，函数模板与普通函数类似，只要是以关键字template开始，后接模板参数列表；类模板与普通类的关系类似；
在使用上，编译器会根据调用来推断函数模板的模板参数的类型，类模板实例化特定类就必须显式地指定模板参数

ex16_10

当使用一个类模板时，必须显式地提供模板实参列表，编译器将它们绑定到模板参数，来替换类模板定义中模板参数出现的地方，这样就实例化出一个特定的类，我们随后使用的其实是这个特定的类

ex16_11

类模板的名字不是一个类型名，类模板用来实例化类型，而一个实例化的类型总是包含模板参数的，因此，在上述代码中直接使用ListItem是错误的，应该使用ListItem<element>,这才是一个类型的名字；
  另一方面，在类模板自己的作用域中，可以直接使用模板名而不提供实参，即上述代码中，类内的List<elemType>可以简化为List

ex16_13

因为函数模板的实例化只处理特定类型，因此，对于相等和关系运算符，对每个BlobPtr实例与相同类型实例化的运算符建立一对一的友好关系即可

ex16_17

当用来声明模板类型的参数时，typename和class是完全等价的，都表明模板参数时一个类型。在C++最初引入模板时，是使用class的，但是为了避免与类定义中的class弄混，引入了typename关键字，从字面上看，typename还暗示了模板类型参数不必是一个类类型，因此，现在更建议使用typename
  当我们希望通知编译器一个名字表示类类型的时候，必须使用关键字typename，而不能使用class
  
ex16_18

（a）是非法的，必须指出U是类型参数还是非类型参数；
（b）是非法的，在作用域中，模板参数名不能重用，这里重用T作为函数参数名了
（c）是非法的，inline智能放在模板参数列表之后，即template<typename T> inline T foo(T,unsigned int*);
（d）是非法的，因为没有指定函数模板返回类型
（e）是合法的，在模板作用域中，类型参数Ctype屏蔽了之前定义的类型别名Ctype


ex16_22

两种指针类型重载删除器的方式不同：
unique_ptr<int,Debugdelete> m(new int,Debugdelete());//P418页见表12.4第3个
shared_ptr<int> n(new int,Debugdelete());//P412页见表12.3第3个

ex16_23

当shared_ptr的引用计数变为0时，需要释放资源时，就会调用删除器进行资源释放。分析插叙你的主程序可知，runQueries函数结束时，TextQuery对象tq声明周期结束，此时shared_ptr的引用计数变为0，会调用删除器进行资源的释放，调用运算符被执行并释放资源，打印一条信息，由于runQueries是主函数最后执行的语句，因此运行效果是程序结束前最后打印出信息

ex16_25

第一条语句的extern表明不在本文件中生成实例化代码，该实例化的代定义会在程序的其他文件中
第二条语句用Sales_data实例化vector，在其他文件中可用extern声明此实例化，使用此定义

ex16_26

不可以，因为显式实例化vector<Nodefault>时，编译器会实例化vector的所有成员函数，包括它接受容器大小参数的构造函数。vector的这个构造函数会使用元素类型的默认构造函数来对元素进行值初始化，而Nodefault没有默认构造函数，从而导致编译错误
  
ex16_27

（a）、（b）（c）、（f）分别发生了Stack对char、double、int和string的实例化，因为这些语句都要用到这些实例化的类
（d）、（e）没有发生实例化，因为在本文件之前的位置已经发生所需要的实例化了

ex16_31

shared_ptr是运行时绑定删除器，而unique_ptr是在编译时绑定删除器，unique_ptr有两个模板参数，一个是所管理的对象类型，另一个是删除器类型。因此，删除器类型是unique_ptr类型的一部分，在编译时就可以知道，删除器可以直接保存在unique_ptr对象中，通过这种方式，unique_ptr避免了间接调用删除器运行时的开销，而编译时还可以将自定义的删除器，如DebugDelete编译为内联形式

ex16_32

对一个函数模板，当调用它们的时候，编译器会利用调用中的函数实参来推断其模板参数，这些模板实参实例化处的版本与我们的函数调用应该是最匹配的版本，这个过程就称为模板实参推断

ex16_33

在模板实参的推断过程中，如果函数形参的类型使用了模板类型的参数，则只允许进行两种类型转换：
1.const转换：可以将一个非const对象的引用（或指针）传递给一个const对象（或指针）形参
2.数组或函数到指针的转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换，一个数组实参可以转换为一个指向其首元素的指针，类似的，一个函数实参可以转换为一个该函数类型的指针

ex16_34

在模板实参推断过程中，允许数组到指针的转换，但是，如果形参是一个引用，则数组不会转换为一个指针，因此，两个调用都是非法的

ex16_35

（a）的调用是合法的，因为calc的第二个参数是int类型的，所以可以进行正常的类型转换，将char转换为int，而T被推断为char；
（b）的调用是合法的，因为calc的第二次参数是float，所以应该把f从float类型转换为int类型，T被推断为double类型
（c）的调用是合法的，c和'c'都是char类型，T被推断为char
（d）的调用是非法的，d为double类型，f是float类型，所以无法推断出T的适配类型应该是什么

ex16_36

(a)的调用是合法的，T被推断为int*
(b)的调用是合法的，T1和T2都被推断为int*
(c)的调用是合法的，T被推断为const int*
(d)的调用是合法的，T1和T2都被推断为const int*
(e)的调用是非法的，T被推断为int* 或者是const int * 都不能匹配调用
(f)的调用是合法的，T1倍推断为int * ，T2被推断为const int *

ex16_37

由题意应该应用显式模板实参来完成这个需求：可以定义一个int和double调用max，显式指定模板实参即可：
auto m=max<double>(1,2.0)
  
ex16_38

该函数接收的实参是迭代器或指针，如果不给出实参类型，那么就不知道分配内存的大小

ex16_40

这段程序是合法的，但是使用decltype(* beg+0)会导致两个问题：
1.序列元素类型必须支持+运算
2.* beg + 0是右值，因此fcn3的返回类型被推断为元素类型的常量引用

ex16_42

T是int&，val的类型是int&，原因是，当实参是一个左值时，编译器推断T为实参左值引用类型，而非左值类型，而int& &&的引用折叠规则的作用下，被折叠为int&

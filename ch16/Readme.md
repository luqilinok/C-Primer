ex16_01

当调用一个函数模板时，编译器会利用给定的函数实参来推断模板实参，用此实际实参代替模板参数来创建出一个新的“实例”，也就是一个真正可以调用的函数，这个过程称为实例化

ex16_03

在gcc-4.8.1中，对两个Sales_data对象调用compare函数模板，编译器会报告如下错误。原因是compare是用<运算符来比较两个对象的，需要类型T实现定义<运算符，但是Sales_data类没有定义<运算符，所以会报错
error:no match for 'operator<'(operand types are 'const Sales_data') and 'const Sales_data'

ex16_06

begin应返回数组首元素的指针，因此是return &a[0],end返回尾后指针，因此在begin上加上数组大小N即可，模板定义请看ex16_06.h

ex16_08

泛型编程的一个目标就是令算法是“通用的”，这样就能够适应不同的类型，所有标准库容器都定义了==和!=运算符，但是只有少量定义了<运算符，因此，尽量使用!=而不是<,可以减少算法适用容器的限制

ex16_09

函数模板是可以实例化出特定函数的模板，类模板是可以实例化出特定类的模板；
从形式上来说，函数模板与普通函数类似，只要是以关键字template开始，后接模板参数列表；类模板与普通类的关系类似；
在使用上，编译器会根据调用来推断函数模板的模板参数的类型，类模板实例化特定类就必须显式地指定模板参数

ex16_10

当使用一个类模板时，必须显式地提供模板实参列表，编译器将它们绑定到模板参数，来替换类模板定义中模板参数出现的地方，这样就实例化出一个特定的类，我们随后使用的其实是这个特定的类

ex16_11

类模板的名字不是一个类型名，类模板用来实例化类型，而一个实例化的类型总是包含模板参数的，因此，在上述代码中直接使用ListItem是错误的，应该使用ListItem<element>,这才是一个类型的名字；
  另一方面，在类模板自己的作用域中，可以直接使用模板名而不提供实参，即上述代码中，类内的List<elemType>可以简化为List

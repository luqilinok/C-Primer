ex6_1

形参出现在函数定义的部分，形参列表可以包含0个、1个或多个形参，多个形参之间用逗号分隔。形参规定了一个函数所接受数据的类型和数量；
实参是形参的初始值，出现在函数调用的地方，实参和形参的数量相等，实参和形参在初始化的过程中是一一对应的，实参的类型必须与对应的形参类型匹配。

ex6_2

(a)是错误的，因为函数体返回的结果是string类型的，而函数的返回值类型是int型的，二者不一致切不能自动转换，应该进行如下的修改:
         string f()
         {
            string s; 
            //...
            return s;
         }
(b)是错误的:f2没有说明是什么类型的(即函数缺少返回值类型)应进行如下修改:
           void f2(int i){/*...*/}
(c)是错误的:1.C++规定任意两个形参不能同名，2.函数左侧的花括号丢了。应进行如下修改:
            int calc(int v1,int v2){/*...*/}
(d)是错误的，形参缺少花括号，应进行如下的修改:
            double square (double x)
            {
              return x*x;
            }
            
ex6_6

形参和函数体内部定义的变量统称为局部变量，局部变量仅在函数的作用域内可见；
函数体内的局部变量又分为普通局部变量和静态局部变量；

局部变量：形参和函数体内部定义的变量统称为局部变量（注意其作用域）
局部静态对象：直到程序的结束才被销毁的对象，不受块的约束
            
ex6_12

与使用指针相比，使用引用交换变量的内容从形式上看更简单一些，并且无需额声明指针变量，也避免了拷贝指针的值。

ex6_13

void f(T)的形参采用的是传值调用的方式，即实参的值被拷贝给形参，形参和实参是两个相互独立的对象，在函数f内部对形参所做的任何改动都不会影响到实参的值；
void f(T&)的形参采用的是传引用调用的方式，即形参是对应的实参的别名，形参绑定到初始化它的对象，如果我们改变了形参的值，也就是改变了实参的值。

ex6_16

该函数的局限性在于将s定义为普通的引用，正如前面书中说道：使用引用而非常量引用会极大地限制函数所能接受的实参类型，而且如果其他函数将它们的形参定义成了
常量引用，那么普通引用版本的函数无法在此类函数中继续引用，应该进行如下修改：
             bool is_empty(const string& s){return s.empty();}

ex6_18

(a)的函数声明是：
bool compare(const matrix&,const matrix&)
(b)的函数声明是：
vactor<int>::iterator change_val()(int,vactor<int>::iterator)  //因为从给定的名字可以看出该迭代器需要可读可写，所以选用的迭代器类型是iterator

ex6_19

(a)是非法的：因为double calc(double)只包含一个double类型，而(a)中调用了两个double类型，因此说（a）是非法的；
(b)是合法的：因为int count(const string&, char)包含了一个常量字符串和一个普通字符类型，(b)中，用双引号“”引用的是字符串类型，用单引号''引用的是字符类型，即“abcda”是字符串，‘a’是字符，符合int count函数的规则，因此说（b）是合法的
(c)是合法的：因为虽然double calc(double)要求函数中的参数是一个double类型的数据，66是一个int类型的数据，但int型的数据可以转换成double类型的数据，所以（c）是合法的
(d)是合法的，因为vec.begin()和vec.end()的类型都是形参所需的vector<int>::iterator,第三个实参3.8可以自动转换为形参所需的int类型


ex6_20

如果不需要修改形参的内容，最好应该将形参设为常量引用类型；如果需要修改形参的内容，就把形参设置为普通引用类型
如果形参应该是常量引用，而我们将其设定为普通引用，那么会出现两个问题：
  1.容易给使用者造成误导，即程序允许修改实参的内容；
  2.极大地限制了该函数所能接受的实参类型，无法把const对象、字面值常量或者需要类型转换的对象传递给普通的引用类型

ex6_21

该函数定义了一个整形常量的数组，由“如果我们传给print函数的是一个数组，则实参自动地转换成指向数组首元素的指针”，可知本题中print函数的形参等价于一个常量整形指针const int*
另一方面根据数据的性质可知不能够拷贝数组，所以本段代码的错误在与用值传递的方式使用了数组的参数 应该进行如下的修改
   void print(const int (&ia)[10])
   {
      for(size_t i=0;i!=10;++i)
        cout<<ia[i]<<endl;
   }

ex6_24

根据数组的性质可知不能拷贝数组，所以不能用值传递的方式使用数组参数，这段代码犯的错误就是用值传递的方式使用了数组的参数，应该进行如下修改：
        void print(const int (&ia)[10])
        {
         for(size_t i=0;i!=10;++i)
         cout<<ia[i]<<endl;
        }

ex6_28

在包含Errcode的版本中，循环elem的初始值是initializer<string>,所以说elem的类型是const string类型的，使用引用的原因在189页：避免拷贝较长的字符串
使用常量的原因是因为只需要读取字符串，并不需要修改它，所以使用常量

ex5_1

空语句是只一条语句中只含有一个单独分号的语句；如果在程序的某个地方，语法上需要一条语句但是逻辑上完全不需要，那么就需要使用空语句。

ex5_2

块就是复合语句，复合语句的定义就是用花括号括起来的语句和声明的序列；如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，那么这种情况就应该使用复合语句，即使用块。

ex5_3

将while循环进行修改后，while循环会变成：while（val<=10）
                                      sum+=val,++val
可以发现，经过修改后的代码没有一开始带有花括号的代码清晰，可读性也变差了。

ex5_4

(a)这段程序的本意是定义一个string::iterator类型的对象iterator，并判断其是否到达s的末尾，如果还没有到达末尾，那么就执行循环体内的内容；但是这段程序是非法的：因为其他代码也需要访问控制变量时，变量需要定义在语句的外部，所以（a）的错误是：iter变量未初始化，且需要定义在语句的外部，应该修改为：
                  string::iterator iter=s.begin();
                  while(iter!=s.end())
                  {
                    ++iter;
                    /*...*/
                  }
(b)status定义在while循环中，所以作用域在while的花括号内，if语句中使用的status是未定义的，所以这段程序是非法的，应改为：
                  bool status;
                  while(status=find(word)){/*....*/}
                  if(!status){/*...*/}
                  
ex5_7
(a).ival1=ival2这条语句没有用分号结束，应该修改为：
          if(ival1!=ival2)
             ival1=ival2;
          else ival1=ival2=0;
(b) 如果occurs=1也是if循环语句中的句子，则应该用花括号括起来作为一个语句块才行，应修改为：
              if(ival<minval)
              {
                minval=ival;
                occurs=1;
              }
(c)ival仅仅是定义在第一个if语句中的变量，如果想在第二个if语句中也使用该变量，那么，该变量应该定义在两个if语句之外，应修改为：
               int ival;
               if(ival=get_value())
                  cout<<"ival = "<<ival<<endl;
               if(!ival)
                  cout<<"ival=0\n";
(d)这段语句的原意是想判断ival的值是否为0，而这段程序的真正含义是将0赋值给ival，那么条件永远都不会满足，应修改为：
                if(ival == 0)
                 ival=get_value();
 ex5_8
 
 悬垂else是指当程序中的if分支多于else分支时，如何为else寻找与之匹配的if分支的问题
 C++规定，else与离它最近的尚未匹配的if匹配，从而消除了二义性。

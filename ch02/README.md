ex2_1

在C++语言中，int,long,long long,short都表示整形，区别在于所表示的整形的精度不同（标准说法是尺寸的最小值，即该类型在内存中所占的比特数不同。其中，short表示短整型，占16位，long和long long均为长整型，分别占32位和64位。）C++标准允许不同的编译器赋予这些类型更大的尺寸，某一类型所占的比特数不同，它所能表达的数据范围也不一样。
大多数整形都可以划分为无符号类型和带符号类型，在无符号类型中所有比特都用来存储数值，但是仅能表示大于0的值；带符号类型则可以表示正数、负数或0.
float和double分别表示单精度浮点数和双精度浮点数，区别主要是在内存中所占的比特数不同，以及默认规定的有效位数不同。

ex2_2

对于利率、本金和付款分别应选择双精度浮点数（double型），因为这些数据都可能出现小数点，所以选用双精度浮点数更合适。

ex2_5

(a) 'a'表示字符a；

    L'a'表示宽字符行字面值a且类型是wchar_t；
    
    "a"表示字符串a；
    
	L"a"表示宽字符型字符串a。
	
(b) 10是一个普通的整数型字面值；

    10u表示一个无符号数，10L表示一个长整型，10uL表示一个无符号长整型，012是一个八进制数（转换为十进制为10），0xc是16进制的数（对应10进制的12）
    
(c) 3.14是一个普通的浮点数，3.14f表示这是一个float型的单精度浮点数，3.14L表示这是一个long double类型的扩展精度浮点数。

(d) 10是一个整数，10u表示这是一个无符号整数，10.是一个浮点数，10e-2是一个用科学记数法表示的浮点数，大小为10*10^2=0.1

ex2_6

第一组定义是正确的，定义了2个十进制数9和7，

第二组数的定义是错误的，因为0开头表示的应该是8进制数，但是数字9显然超过了8进制数的表示范围，将编译失败。

ex2_7

(a) 是一个字符串，包含两个转义字符，其中\145表示字符e，\012表示一个换行符，因此该字符串的输出结果是：“Who goes with Fergues?”

(b) 是一个一个科学记数法表示的扩展精度的浮点数大小为3.14*10^1 = 31.4,

(c) 试图表示一个单精度浮点数，但是该形式在某些编译器会报错，因为后缀f直接跟在了1024的后面，应该改写为1024.f；

(d) 是一个扩展精度的浮点数，类型是long double，大小为3.14。

ex2_10

std::string global_str;  string类型本身接受无参数的初始化方式，所以无论变量定义在函数内还是函数外都被默认初始化为空串；
内置类型int，变量global_int定义在所有函数整体之外，根据规则，global_int默认初始化为0

对于函数
(a).int double = 3.14是非法的，因为double是C++固有的关键字，不能用来当作变量名称；

(b).int_是正确的；

(c).int catch-22是错误的，因为变量命名不允许“-”号的出现

(d).是错误的，因为变量名只能够以字幕或下划线开头，d中是以数字开头的，所以是错误的；

(e).是正确的

ex2_15

(b)是错误的，因为b直接为引用赋值，但是引用应该先指向一个变量， 为该变量赋值;

(d)是错误的，因为d引用的对象没有初始化。

(a)、(c)是正确的。

ex2_16

(a)是合法的，执行的操作是将r2=3.14159赋值给了d;

(b)是合法的，执行的操作是将r1=i=0赋值给了r2;

(c)是合法的，执行的操作是将r2引用的值d赋值给i;

(d)是合法的，执行的操作是将d赋值给r1引用的值i。

ex2_19

指针“指向”内存中的某个对象，引用是“绑定到内存”中的某个对象，二者都实现了对其他对象的间接访问;

二者的区别在于：

	 1.指针本身就是一个对象，允许对指针进行赋值和拷贝，而且指针的生命周期内，允许指针可以指向几个不同的对象；
	 
	 引用本身不是对象，无法令引用重新绑定到另外一个对象。
	 
	 2.指针无需在定义时就赋初值，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；
	 
	   引用必须在定义时就赋初值。
	   

ex2_20

这段代码首先定义了一个int型的变量i，并为i赋初值42，

随后又定义了一个int型的指针p1，令其指向变量i;最后取出p1所指的当前值，计算平方后重新赋给p1所指的变量i。

第二行的*表示声明一个指针，第三行的*表示解引用运算，即取出指针p1所指对象的值。

ex2_21

(a)是非法的，dp是一个double型的指针，i是一个int型的变量，类型不匹配;

(b)是非法的，不能直接把int型的i赋值给int型的指针ip，应该是通过取地址运算符&i得到变量i在内存中的地址，然后再将地址赋给指针。

(c)是合法的。

ex2_22

1.指针p作为if语句的条件时，实际检验的是指针本身的值，即指针所指的地址值，如果指针指向一个真实存在的变量，其值必不为0，此时条件为真；如果指针没有指向任何对象或者就是一个无效的指针，那么对p的使用将不可预计结果。

2.解引用运算符*p作为if语句的条件时，实际检验的是指针所指的对象内容，在上面的示例中是指针p所指的int值。如果该int值为0，则条件为假，否则，如果该int值的值不为0，则对应条件为真。

ex2_23

可以将指针先初始化，这样就能够知道该指针是否指向了一个合法的对象。

ex2_24

p指针是void类型的指针，i是int类型的数据，所以该语句表示将p指针指向i的地址；

lp指针是long型的，但是i是int型的数据，则二者的类型不匹配。

ex2_25

(a)ip是一个int型指针，它的值是所指的整形数在内存中的地址；

   i是一个整形的数：r是一个引用，它绑定了i，可以看作是i的别名，r的值实际上就是i的值。

(b)i是一个整形的数，它的值是0；

   ip是一个整形的指针，但是它不指向任何一个具体的值，所以它的值初始化为0。

(c)ip是一个整形的指针，指向一个整形数，它的值是所指的整形数在内存中的地址；

   ip是一个整形数。
   
 ex2_26
 
(a)是不合法的因为buf没有初始化；

(b)是合法的；

(c)是合法的；

(d)是非法的，因为sz是const类型的，不可以改变它的值，所以不能进行自增操作

ex2_27

(a)是非法的，因为引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起；

(b)是合法，p2是一个常量指针，p2的值永远不变，即p2永远指向i2变量；

(c)是合法的，i是一个常量，r是一个常量引用，此时r可以绑定到字面值常量0.

(d)是合法的，p3是一个常量指针，p3的值是永远都不会改变的，即p3永远指向变量i2；同时p3指向的是常量，即我们不能通过p3改变所指对象的值.

(e)是合法的，p1指向一个常量，即不能通过p1改变所指对象i2的值；

(f)是非法的，因为引用本身并不是对象，因此不能让引用恒定不变。

(g)是合法的，i2是一个常量，r是一个常量引用。

ex2_28

(a)是不合法的:因为cp是一个常量指针，其值不能改变，所以必须初始化;

(b)是不合法的:p2是一个常量指针，必须初始化;

(c)是非法的：ic是一个常量，其值不能改变，所以必须初始化。

(d)是非法的，因为p3是一个常量指针，其值不能被改变，所以必须要初始化。同时p3指向的是常量，即我们不能通过p3改变所指对象的值；

(e)是合法的，但p没有指向任何实际的对象.

ex2_29

(a)是合法的，常量ic的值赋给了非常量i.

(b)是非法的，普通指针p1指向了一个常量，从语法上说，p1的值可以随意改变。

(c)是非法的，p1是一个普通的指针，ic是一个常量，引用ic赋值给p1是非法的，因为p1作为一个普通的指针，它的值是可以任意改变的。

(d)是非法的，p3是一个常量指针，ic是一个常量，不能对常量指针赋值；

(e)是非法的，p2是一个常量指针，不能被赋值;

(f)是非法的，ic是一个常量，不能被赋值。

ex2_30

v2和p3都被声明成为了一个顶层const，v2表示一个整形常量，p3表示一个整形常量指针；

p2和r2是底层const，因为p2是一个指针，且它指向的对象是一个常量，所以p2是一个底层const，r2是一个引用，因为引用的v2是一个常量，所以r2是一个底层const。

ex2_31

r1=v2是合法的，r1是一个非常量引用，v2是一个常量引用，可以看成是顶层const，把v2的值拷贝到r1不会对v2产生影响；

p1=p2是非法的，因为p1是普通指针，指向的对象可以是任意值，p2是指向常量的指针，可以看成是底层const，令p1指向p2的内容可能会错误的改变常量的值；

p2=p1是合法的，p2可以指向一个非常量；

p1=p3是非法的，因为p3是一个底层const，不能把p3的值赋给普通的指针；

p2=p3是合法的，p2=p3都是底层const

ex2_32

这段代码是非法的，因为null是一个int型的变量，p是一个int型的指针，二者不能直接绑定。可以修改为：

int null = o;*p=null;

ex2_33

前三条语句的赋值是合法的：

r是i的别名，i是一个整数，所以auto推断出a也是一个整数；
ci是一个整型常量，在类型推断时顶层const被忽略掉了，所以b也是一个整数；
cr是ci的别名，ci是一个整形常量，所以推断出c也是一个整数；因为a、b、c都是整数，所以为其赋值是42是合法的。

后3条语句是非法的：

i是一个整数，&i表示i的地址，所以d的类型推断结果是一个整形指针；
ci是一个整形常量，&ci表示整型常量的地址，所以e的类型推断结果是一个整形常量引用。
因为d和e都是指针，所以不能直接用字面值常量为其赋值；g引用了ci的值，即g被ci绑定了，所以不能修改它的值

ex2_35

i是一个整形的常量，j的类型结果推断为整数，k的类型推断结果是整形常量，p的类型结果推断是指向整形常量的指针，j2的类型推断结果是整数，k2的类型推断结果是整数。

ex2_36

c的类型是a的类型，即该语句等同于int c = a；所以这时候c是一个int类型的数据，值为3；

decltype((b)) d =a;使用的是一个加了括号的变量，因此d的类型是引用，即该语句等同于int &d=a;此时d是变量a的别名；

执行++c，++d时，变量c的值自增为4；又因为d是a的别名，所以d自增1意味着a的值变成了4.当程序结束时，a、b、c、d的值都是4.

ex2_37

c的类型是int型，值为3；

a=b作为decltype的参数，编译器分析表达式并得到它的类型作为d的推断类型，但是不实际计算该表达式，所以a的值不发生改变，仍然是3；
d的类型是int&，d是a的别名，值是3，b的值没有发生改变，为4；

ex2_38

decltype和auto的区别在于：
1.auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式，并得到它的类型，但是不实际的计算表达式的值；

2.编译器有时推断出的auto类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化的规则，例如：auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const；

3.与auto不同，decltype的结果类型与表达式的形式密切相关，如果变量名前加了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用的类型。
	
ex2_39

该程序无法编译通过，原因是缺少了一个分号，因为类体后面可以紧跟变量名以表示对该类型对象的定义，所以在类体右侧表示结束的花括号之后必须写一个分号。


ex2_40

struct Sales_data{
	std::string bookNO;  //书籍编号
	unsigned units_sold =0;  //销售量
	double sellingprice =0.0;  //实售价
	double discount=0.0  //折扣
}

ex9_01

(a).由题意可知这个容器可能会在中间的位置添加元素（因为添加的元素需要按照字典顺序插入），所以根据容器选择的原则应该选择list（双向链表）；
(b).因为单词的数量是未知的，而且要在尾部插入，头部删除，所以应该选择的容器时deque（双端队列）；
(c).因为不知道整数的大小，而且没有具体的插入删除操作，应该选择vector；

ex9_02

#include<iostream>
#include<deque>
#include<list>

using namespace std;

list<deque<int>> a;

ex9_03

对于构成迭代器范围的迭代器，应该满足如下条件：
两个迭代器begin和end必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对begin反复进行递增操作，可以保证到达end（end不在begin的前面）

ex9_04

list迭代器不支持<运算只支持递增、递减、==以及！=运算

ex9_05

为了索引int的vector中的元素，可以使用迭代器类型vector<int>::iterator

ex9_06

如果需要读取string的list中的元素，根据书中写到的“如果需要元素类型，可以使用容器的value_type”这句话，所以应该使用list<string>::value_type;
如果需要写入list，那么需要非常量的引用类型，所以根据书中的“如果需要元素类型的一个引用，可以使用reference或const_reference”这句话，又因为是写入，所以不能是常量引用，所以用的类型是list<string>::reference

ex9_09

begin返回的是普通版本的迭代器，可读可写（可以修改）；cbegin返回的const版本的迭代器（不能够修改）

ex9_10

v1是int的vector类型，我们可以修改v1的内容，所以是	vector<int>::iterator;
v2是int的常量vector类型，内容不可以修改，所以是const vector<int>::iterator;
根据书中的描述，“当auto与begin或end结合使用的时候，获得的迭代器类型依赖于容器类型”，所以it1是普通迭代器，可以对其进行修改it2是const迭代器，不能对其进行修改；
又因为“以c开头的版本无论容器的类型是什么，都可以获得const_iterator”，所以it3和it4都是const迭代器

ex9_11

6种创建和初始化vector对象的方法：
	• 默认初始化:vector<int> ilist1
	• 拷贝初始化:vector<int> ilist2(ilist1)
	• 列表初始化:vector<int> ilist={1,2,3}
	• 范围初始化:vector<int> ilist3(ilist.begin()+2,ilist.end()-1)
	• 默认值初始化:vector<int> ilist(8)
	• 指定值初始化:vector<int> ilist(7,3)   ilist被初始化为包含7个值为3的int

ex9_12

当接受一个容器创建其拷贝的构造函数时，要求两个容器的类型及元素类型必须匹配
当接受两个迭代器创建拷贝的构造函数时，不要求容器类型是相同的了，只要能将拷贝的元素转换为要初始化的容器的元素类型即可

ex9_13

因为list<int>和vector<double>容器类型不同、元素类型也不同，所以要执行初始化操作应该采用迭代器范围初始化的方法来构造一个vector<double>,让它的元素值与list<int>完全相同

#include<iostream>
#include<vector>
#include<list>
#include<string>

using std::vector;
using std::list;
using namespace std;

int main()
{
	list<int> ilist(5, 4);
	vector<int> ivec(5, 5);

	//从list<int>初始化vector<double>
	vector<double> dvec(ilist.begin(), ilist.end());
	for (auto i:ilist)
	{
		cout << i << " " << endl;
	}
	for (auto d : dvec)
	{
		cout << d << " ";
	}

	//从vector<int>初始化vector<double>
	vector<double> dvec2(ivec.begin(), ivec.end());
	for (auto i:ivec)
	{
		cout << i << " " << endl;
	}
	for (auto d : dvec2)
	{
		cout << d << " ";
	}

	system("pause");
	return 0;
}


ex9_01

(a).由题意可知这个容器可能会在中间的位置添加元素（因为添加的元素需要按照字典顺序插入），所以根据容器选择的原则应该选择list（双向链表）；
(b).因为单词的数量是未知的，而且要在尾部插入，头部删除，所以应该选择的容器时deque（双端队列）；
(c).因为不知道整数的大小，而且没有具体的插入删除操作，应该选择vector；

ex9_02

#include<iostream>
#include<deque>
#include<list>

using namespace std;

list<deque<int>> a;

ex9_03

对于构成迭代器范围的迭代器，应该满足如下条件：
两个迭代器begin和end必须指向同一个容器中的元素，或者是容器最后一个元素之后的位置；
而且，对begin反复进行递增操作，可以保证到达end（end不在begin的前面）

ex9_04

list迭代器不支持<运算只支持递增、递减、==以及！=运算

ex9_05

为了索引int的vector中的元素，可以使用迭代器类型vector<int>::iterator

ex9_06

如果需要读取string的list中的元素，根据书中写到的“如果需要元素类型，可以使用容器的value_type”这句话，所以应该使用list<string>::value_type;
如果需要写入list，那么需要非常量的引用类型，所以根据书中的“如果需要元素类型的一个引用，可以使用reference或const_reference”这句话，又因为是写入，所以不能是常量引用，所以用的类型是list<string>::reference

ex9_09

begin返回的是普通版本的迭代器，可读可写（可以修改）；cbegin返回的const版本的迭代器（不能够修改）

ex9_10

v1是int的vector类型，我们可以修改v1的内容，所以是	vector<int>::iterator;
v2是int的常量vector类型，内容不可以修改，所以是const vector<int>::iterator;
根据书中的描述，“当auto与begin或end结合使用的时候，获得的迭代器类型依赖于容器类型”，所以it1是普通迭代器，可以对其进行修改it2是const迭代器，不能对其进行修改；
又因为“以c开头的版本无论容器的类型是什么，都可以获得const_iterator”，所以it3和it4都是const迭代器

ex9_11

6种创建和初始化vector对象的方法：
	• 默认初始化:vector<int> ilist1
	• 拷贝初始化:vector<int> ilist2(ilist1)
	• 列表初始化:vector<int> ilist={1,2,3}
	• 范围初始化:vector<int> ilist3(ilist.begin()+2,ilist.end()-1)
	• 默认值初始化:vector<int> ilist(8)
	• 指定值初始化:vector<int> ilist(7,3)   ilist被初始化为包含7个值为3的int

ex9_12

当接受一个容器创建其拷贝的构造函数时，要求两个容器的类型及元素类型必须匹配
当接受两个迭代器创建拷贝的构造函数时，不要求容器类型是相同的了，只要能将拷贝的元素转换为要初始化的容器的元素类型即可

ex9_13

因为list<int>和vector<double>容器类型不同、元素类型也不同，所以要执行初始化操作应该采用迭代器范围初始化的方法来构造一个vector<double>,让它的元素值与list<int>完全相同

#include<iostream>
#include<vector>
#include<list>
#include<string>

using std::vector;
using std::list;
using namespace std;

int main()
{
	list<int> ilist(5, 4);
	vector<int> ivec(5, 5);

	//从list<int>初始化vector<double>
	vector<double> dvec(ilist.begin(), ilist.end());
	for (auto i:ilist)
	{
		cout << i << " " << endl;
	}
	for (auto d : dvec)
	{
		cout << d << " ";
	}

	//从vector<int>初始化vector<double>
	vector<double> dvec2(ivec.begin(), ivec.end());
	for (auto i:ivec)
	{
		cout << i << " " << endl;
	}
	for (auto d : dvec2)
	{
		cout << d << " ";
	}

	system("pause");
	return 0;
}

ex9_16

.比较两个容器是否相等的步骤：
	• 首先判断两个容器是否包含相同个数的元素，若不等，则两个容器也不等
	• 否则，遍历两个容器中的元素，两两比较对位元素的值，若有元素不相等，则容器不等，否则，两个容器相等

ex9_17

首先这两个容器类型必须相同，其次容器中的元素类型也必须相同

ex9_23

如果将c.size()设置为1，那么证明该容器的容量是1，所以c.begin()、c.end()指向的是同一个元素，所以val1、val2、val3和val4的值都是一个，都是*c.begin()

ex9_25

如果两个迭代器elem1和elem2相等，那么什么也不会发生，容器保持不变
如果两个容器都是尾后迭代器，容器也会保持不变
如果elem1是指向之前合法位置的迭代器，elem2是尾后迭代器，那么，eraser操作将会删除从elem11到容器末尾的所有元素

ex9_29

根据resize的定义，vec.resize(100)会在vec容器的后部添加75个元素，这些元素将进行值初始化；
接下来的vec.risize(10)将会删除此时vec容器100个容器中后面90个元素

ex9_30

根据书中说到，如果容器保存的是类类型元素，且resize向容器添加新元素，那么我们必须提供初始值，或者元素类型必须提供一个默认构造函数

ex9_31

这段程序之所以不能用于list或forward_list的原因是根据书中296页所说：forward_list不支持递减运算，所以推理可得，list也不支持递减运算，即list和forward_list不支持迭代器的递增/递减运算，因此这段程序应进行修改，请看ex9_31(list).cpp、ex9_31(forward_list).cpp

ex9_32

不合法，：++高于*解引用符号，因此iter=vi.insert(iter,*iter++)就不是复制当前元素了，复制的是奇数后面的一个数。和题目要求的不符合

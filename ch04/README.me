ex4_1

该表达式的运算结果是105.

ex4_2

(a)*（vec.begin()） (b)(*(vec.begin()))+1

ex4_3

正如题目所说，C++只规定了非常少的二元运算符（逻辑与运算符、逻辑或运算符、逗号运算符）的求值顺序，其他绝大多数二元运算符的求值顺序并没有明确规定，尽管这种方法可能会引发潜在的风险，但是仍然是可以接受的：因为我们只要注意两点：（1）在拿不准的时候主动用括号来强制让表达式的组合关系符合程序的逻辑要求；（2）一旦改变了某个运算对象的值，在表达式的其他地方就不要再用这个运算对象了（当改变对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效）。当注意这两点以后，就可以发挥出提高代码生成效率的优势，降低风险。

ex4_4

（（12/3）*4）+（5*15）+(（24%4）/2)=91;

ex4_5

(a).-(30*3)+(21/5)=-86;
(b).-30+((3*21)/5)=-18;
(c).((30/3)*21)%5=0;
(d).((-30/3)*21)%4=-2.

ex4_6

假设该整数名为num，则表达式num%2==0为真是偶数，该表达式为假时num是奇数。

ex4_7

溢出是一种常见的算术运算错误，因为在计算机中存储某种类型的内存空间有限，所以该类型的表示能力（范围）也是有限的，当计算的结果值超出这个范围时，就会产生未定义的数值，这种错误称为溢出。

假定编译器规定int占32位，则下面3条表达式将产生溢出错误：
int i =2147483647+1;
int j=-100000*300000;
int k=2015*2015*2015*2015.

 ex4_8
 
 逻辑与运算符的求值顺序是从左向右的，左右两侧的运算结果必须都为真则逻辑与表达式的结果为真，左侧运算对象结果无法确定表达式的结果时才会计算右侧表达式的运算结果，
 逻辑或运算符的求值顺序也是从左向右的，左右两侧的运算结果有一个为真则逻辑或表达式的结果为真，当且仅当左侧运算结果为假时才计算右侧运算对象的结果。
 相等运算符的两个运算结果都需要求值，C++没有规定其求值顺序。

ex4_9

首先这段代码定义了一个常量字符指针cp，并为其赋值为：Hello World，条件语句if的意思是：先检查指针cp是否有效，如果cp为空指针或者是无效的指针，则条件不满足。如果cp有效，即cp指向了内存中某个有效地址，继续解引用指针cp，并检查cp所指的对象是否为空字符'\0',如果cp所指对象不是空字符则条件满足，否则不满足。
   在本例中，初始状态下cp指向了字符串的首字符，是有效的；同时当前cp所指的对象时字符'H',不是空字符，所以if的条件部分为真。


ex4_10

int i;
	while (cin>>i&&i!=42)
 
ex4_11

a>b&&b>c&&c>d

ex4_12

i!=j<k的含义如下：
  因为C++规定<、<=、>、>=的优先级高于==和!=。所以上式的结果等同于i!=(j<k),即先比较j和k的大小，得到的结果是一个布尔值(1或0)；然后判断i的值与之是否相等。


ex4_13

(a)的表达式经过赋值后i的结果为3，d的结果也是3；（b）的表达式的结果经过赋值后的表达式的结果i是3，d经过强制类型转换后的结果也是3.


ex4_14

第一条if语句将报错，因为字符型数值是右值；第二条if语句从语法上来说没有错误，但容易引起歧义，应该改成if(i==42)

ex4_15
下面的赋值当然是非法:首先dval是双精度浮点数，ival是整形，pi是指向int类型的指针，三个变量的类型是不一样的，所以不能放在一起赋值，如果想要消除编译错误，应该进行如下的修改: 

double dval, int ival int *pi;
dval=ival=0;
pi=o;

ex4_16

(a)的原意是把getPtr()得到的指针赋值给p，然后判断p是否是一个空指针，但是上述表达式不会按照这个意思来进行运行，因为赋值运算符的优先级特别低，所以会先执行不相等运算符，再去执行赋值运算符，这样就与原意相违背了，修改的方法是将getPtr()整体加上括号：if((getPtr())!=0);
(b)的原意是判断i的值是否是1024，但是此题中的表达式是将1024赋值给i，所以错了，应该进行如下的修改：if(i==1024)

ex4_17

前置递增运算符的求值结果是改变后的对象；
后置递增运算符的求值结果是运算对象改变之前的那个值的副本。

ex4_18

如果那个输出vector对象元素的while循环使用前置递增运算符，那么程序会输出第二个元素，直到最后一个元素的后一个位置（未知的量，非常危险）
  
ex4_19

(a)判断ptr指针指向的int值是否为0；
(b)判断ival和ival+1的值是否是非0；改写为ival&&(ival+1)
(c)比较vec[ivel]和vec[ivel+1]的大小，如果前者较小，则表达式为真，否则结果为假;改写为:vec[ival]<=vec[ival+1]。

ex4_20

(a)是合法的；因为后置递增运算符的优先级高于解引用运算符的优先级，所以这个表达式的含义是解引用当前迭代器所处位置的对象内容，并将迭代器的位置向后移动一位；
(b)是非法的;表示解引用iter得到vector对象的当前元素，并将当前元素加1，这个表达式是错误的:因为解引用iter得到的元素类型是string类型，而string类型的元素没有后置递增操作，所以这条表达式是非法的。
(c)是非法的;这条表达式试图访问对象iter的empty成员，但是iter是一个指向vector的指针，切不包含任何成员，无法访问其empty成员，所以错了；
(d)是合法的；iter ->empty()等价于(*iter).empty,含义是解引用iter得到迭代器当前所指的元素，结果是一个string类型，可以进行判空操作，因此是正确的；
(e)是非法的:这个表达式先执行解引用操作，即解引用iter，得到迭代器当前所指的元素，结果是一个string类型，接下来执行前置递增操作，因为string没有前置递增操作，所以该表达式是错误的。
(f)是合法的。iter++->empty()等价于(*iter++).empty,该表达式的含义如下:因为后置递增运算符的优先级高于解引用运算符的优先级，所以括号里面的表达式表示解引用迭代器当前位置的对象内容，然后进行判空，因为迭代器当前位置的对象内容是字符串，可以执行判空操作，然后把迭代器向后移动一位。所以该表达式是正确的。

ex4_1

该表达式的运算结果是105.

ex4_2

(a)*（vec.begin()） (b)(*(vec.begin()))+1

ex4_3

正如题目所说，C++只规定了非常少的二元运算符（逻辑与运算符、逻辑或运算符、逗号运算符）的求值顺序，其他绝大多数二元运算符的求值顺序并没有明确规定，尽管这种方法可能会引发潜在的风险，但是仍然是可以接受的：因为我们只要注意两点：（1）在拿不准的时候主动用括号来强制让表达式的组合关系符合程序的逻辑要求；（2）一旦改变了某个运算对象的值，在表达式的其他地方就不要再用这个运算对象了（当改变对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效）。当注意这两点以后，就可以发挥出提高代码生成效率的优势，降低风险。

ex4_4

（（12/3）*4）+（5*15）+(（24%4）/2)=91;

ex4_5

(a).-(30*3)+(21/5)=-86;
(b).-30+((3*21)/5)=-18;
(c).((30/3)*21)%5=0;
(d).((-30/3)*21)%4=-2.

ex4_6

假设该整数名为num，则表达式num%2==0为真是偶数，该表达式为假时num是奇数。

ex4_7

溢出是一种常见的算术运算错误，因为在计算机中存储某种类型的内存空间有限，所以该类型的表示能力（范围）也是有限的，当计算的结果值超出这个范围时，就会产生未定义的数值，这种错误称为溢出。

假定编译器规定int占32位，则下面3条表达式将产生溢出错误：
int i =2147483647+1;
int j=-100000*300000;
int k=2015*2015*2015*2015.

 ex4_8
 
 逻辑与运算符的求值顺序是从左向右的，左右两侧的运算结果必须都为真则逻辑与表达式的结果为真，左侧运算对象结果无法确定表达式的结果时才会计算右侧表达式的运算结果，
 逻辑或运算符的求值顺序也是从左向右的，左右两侧的运算结果有一个为真则逻辑或表达式的结果为真，当且仅当左侧运算结果为假时才计算右侧运算对象的结果。
 相等运算符的两个运算结果都需要求值，C++没有规定其求值顺序。

ex4_9

首先这段代码定义了一个常量字符指针cp，并为其赋值为：Hello World，条件语句if的意思是：先检查指针cp是否有效，如果cp为空指针或者是无效的指针，则条件不满足。如果cp有效，即cp指向了内存中某个有效地址，继续解引用指针cp，并检查cp所指的对象是否为空字符'\0',如果cp所指对象不是空字符则条件满足，否则不满足。
   在本例中，初始状态下cp指向了字符串的首字符，是有效的；同时当前cp所指的对象时字符'H',不是空字符，所以if的条件部分为真。

ex4_1

该表达式的运算结果是105.

ex4_2

(a)*（vec.begin()） (b)(*(vec.begin()))+1

ex4_3

正如题目所说，C++只规定了非常少的二元运算符（逻辑与运算符、逻辑或运算符、逗号运算符）的求值顺序，其他绝大多数二元运算符的求值顺序并没有明确规定，尽管这种方法可能会引发潜在的风险，但是仍然是可以接受的：因为我们只要注意两点：（1）在拿不准的时候主动用括号来强制让表达式的组合关系符合程序的逻辑要求；（2）一旦改变了某个运算对象的值，在表达式的其他地方就不要再用这个运算对象了（当改变对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效）。当注意这两点以后，就可以发挥出提高代码生成效率的优势，降低风险。

ex4_4

（（12/3）*4）+（5*15）+(（24%4）/2)=91;

ex4_5

(a).-(30*3)+(21/5)=-86;
(b).-30+((3*21)/5)=-18;
(c).((30/3)*21)%5=0;
(d).((-30/3)*21)%4=-2.

ex4_6

假设该整数名为num，则表达式num%2==0为真是偶数，该表达式为假时num是奇数。

ex4_7

溢出是一种常见的算术运算错误，因为在计算机中存储某种类型的内存空间有限，所以该类型的表示能力（范围）也是有限的，当计算的结果值超出这个范围时，就会产生未定义的数值，这种错误称为溢出。

假定编译器规定int占32位，则下面3条表达式将产生溢出错误：
int i =2147483647+1;
int j=-100000*300000;
int k=2015*2015*2015*2015.

 ex4_8
 
 逻辑与运算符的求值顺序是从左向右的，左右两侧的运算结果必须都为真则逻辑与表达式的结果为真，左侧运算对象结果无法确定表达式的结果时才会计算右侧表达式的运算结果，
 逻辑或运算符的求值顺序也是从左向右的，左右两侧的运算结果有一个为真则逻辑或表达式的结果为真，当且仅当左侧运算结果为假时才计算右侧运算对象的结果。
 相等运算符的两个运算结果都需要求值，C++没有规定其求值顺序。

ex4_9

首先这段代码定义了一个常量字符指针cp，并为其赋值为：Hello World，条件语句if的意思是：先检查指针cp是否有效，如果cp为空指针或者是无效的指针，则条件不满足。如果cp有效，即cp指向了内存中某个有效地址，继续解引用指针cp，并检查cp所指的对象是否为空字符'\0',如果cp所指对象不是空字符则条件满足，否则不满足。
   在本例中，初始状态下cp指向了字符串的首字符，是有效的；同时当前cp所指的对象时字符'H',不是空字符，所以if的条件部分为真。


ex4_10

int i;
	while (cin>>i&&i!=42)
 
ex4_11

a>b&&b>c&&c>d

ex4_12

i!=j<k的含义如下：
  因为C++规定<、<=、>、>=的优先级高于==和!=。所以上式的结果等同于i!=(j<k),即先比较j和k的大小，得到的结果是一个布尔值(1或0)；然后判断i的值与之是否相等。


ex4_13

(a)的表达式经过赋值后i的结果为3，d的结果也是3；（b）的表达式的结果经过赋值后的表达式的结果i是3，d经过强制类型转换后的结果也是3.


ex4_14

第一条if语句将报错，因为字符型数值是右值；第二条if语句从语法上来说没有错误，但容易引起歧义，应该改成if(i==42)

ex4_15
下面的赋值当然是非法:首先dval是双精度浮点数，ival是整形，pi是指向int类型的指针，三个变量的类型是不一样的，所以不能放在一起赋值，如果想要消除编译错误，应该进行如下的修改: 

double dval, int ival int *pi;
dval=ival=0;
pi=o;

ex4_16

(a)的原意是把getPtr()得到的指针赋值给p，然后判断p是否是一个空指针，但是上述表达式不会按照这个意思来进行运行，因为赋值运算符的优先级特别低，所以会先执行不相等运算符，再去执行赋值运算符，这样就与原意相违背了，修改的方法是将getPtr()整体加上括号：if((getPtr())!=0);
(b)的原意是判断i的值是否是1024，但是此题中的表达式是将1024赋值给i，所以错了，应该进行如下的修改：if(i==1024)

ex4_17

前置递增运算符的求值结果是改变后的对象；
后置递增运算符的求值结果是运算对象改变之前的那个值的副本。

ex4_18

如果那个输出vector对象元素的while循环使用前置递增运算符，那么程序会输出第二个元素，直到最后一个元素的后一个位置（未知的量，非常危险）
  
ex4_19

(a)判断ptr指针指向的int值是否为0；
(b)判断ival和ival+1的值是否是非0；改写为ival&&(ival+1)
(c)比较vec[ivel]和vec[ivel+1]的大小，如果前者较小，则表达式为真，否则结果为假;改写为:vec[ival]<=vec[ival+1]。

ex4_20

(a)是合法的；因为后置递增运算符的优先级高于解引用运算符的优先级，所以这个表达式的含义是解引用当前迭代器所处位置的对象内容，并将迭代器的位置向后移动一位；
(b)是非法的;表示解引用iter得到vector对象的当前元素，并将当前元素加1，这个表达式是错误的:因为解引用iter得到的元素类型是string类型，而string类型的元素没有后置递增操作，所以这条表达式是非法的。
(c)是非法的;这条表达式试图访问对象iter的empty成员，但是iter是一个指向vector的指针，切不包含任何成员，无法访问其empty成员，所以错了；
(d)是合法的；iter ->empty()等价于(*iter).empty,含义是解引用iter得到迭代器当前所指的元素，结果是一个string类型，可以进行判空操作，因此是正确的；
(e)是非法的:这个表达式先执行解引用操作，即解引用iter，得到迭代器当前所指的元素，结果是一个string类型，接下来执行前置递增操作，因为string没有前置递增操作，所以该表达式是错误的。
(f)是合法的。iter++->empty()等价于(*iter++).empty,该表达式的含义如下:因为后置递增运算符的优先级高于解引用运算符的优先级，所以括号里面的表达式表示解引用迭代器当前位置的对象内容，然后进行判空，因为迭代器当前位置的对象内容是字符串，可以执行判空操作，然后把迭代器向后移动一位。所以该表达式是正确的。

ex4_22

我认为使用条件运算符的效果会更好一点，因为由题意可知，如果采用if语句的话，会有很多的if语句，代码的可读性比较差，如果采用条件运算符，就可以很好地避免这些问题。
  当然，条件运算符的嵌套层数也要越少越好，否则代码的可读性就会变得非常差。

ex4_23

对于表达式string p1=s+s[s.size()-1]=='s'?"""s"：其中包含的运算符有赋值运算符（=）、相等运算符（==）、条件运算符（?:）、一元正号（+），根据147页的运算符优先级表可以知道：以上四个运算符的优先级由大到小排列顺序为一元正号（+）>相等运算符（==）>条件运算符（?:）>赋值运算符（=）,所以该表达式的求值过程是先将s和s[s.size()-1]相加得到一个新的字符串，然后该字符串再和字符's'比较是否相等，这是一个非法的操作，因为字符串不能直接和字符进行比较。
 要想实现程序的原意，即先判断字符串s的最后一个字符是否是's',如果是，就什么也不做，如果不是，那么就在字符串s的末尾添加一个字符's'。那么怎么实现这个操作呢--通过括号来无视优先级的顺序
 string p1 = s+(s[s.size()-1] =='s'?"":"s");

ex4_24

如果条件运算符满足的是左结合律，即嵌套的条件运算符从左向右求值，原表达式等价于：finalgrade=((grade>90)?"high pass":(grade<60))?"fail":"pass";
该表达式的含义是：先考察grade>90是否成立，如果成立，第一个条件表达式的值为"high pass";如果不成立，第一个表达式的值为grade<60, 这条语句是无法编译的，因为条件运算符要求两个表达式的类型相同或者可以相互转化。本题中grade<60显然和high pass不是一个类型的，也不能相互转化。
  假设语法通过了，第一个表达式的求值结果有3种：high pass、1或者0，接下来根据第一个表达式的求值结果求解第二个条件表达式，结果将会是fail或者是pass，与期望不符合。

ex4_25

首先，因为q是一个字符型的数据，根据4.1节的内容要进行类型提升，将char型的q提升为int型；又因为在该机器中，char占8位，int占32位，所以进行类型转换之后，q由原来的0111 0001变为00000000 00000000 00000000 01110001。
   根据运算符的优先级可知，位求反运算符的优先级高于左移运算符，所以按位取反的 11111111 11111111 11111111 10001110，接下来执行位移操作，左移6位得到：11111111 11111111 11100011 100000000
    C++规定整数按照其补码形式存储，所以对上式求补码，得到（因为原码的符号位是1-为负数，所以符号位不变，其余各位按位取反，末尾加1）：10000000 00000000 00011100 10000000，转换为十进制为-7296

ex4_26

在C++中规定unsigned int占16位，所以如果本节测试中quiz1采用unsigned int型，那么会出现数据类型不足以存放全部学生的信息，会造成信息的丢失，无法完成题目的要求。

ex4_27

这道题首先应该将变量ul1和ul2转换为二进制，又因为unsigned long占32位，所以：
 ul1转换为二进制为：00000000 00000000 00000000 00000011
 ul2转换为二进制为：00000000 00000000 00000000 00000111
因此各个式子的求值结果分别是：
(a)ul1和ul2执行位与运算，得：00000000 00000000 00000000 00000011;
(b)ul1和ul2执行位或运算，得：00000000 00000000 00000000 00000111;
(c)ul1和ul2执行逻辑与运算，得：所有非0整数对应的布尔值都是true，所以该式等价于true&&true,结果为true.
(d)ul1和ul2执行逻辑或运算，得：所有非0整数对应的布尔值都是true，所以该式等价于true||true,结果为true。

ex4_29

这段程序首先定义了一个包含10个元素的一维数组，指针p指向该数组，第一个表达式用数组所占的空间大小/单个元素所占空间的大小，得到数组的元素个数，结果为10；
第二个表达式用指针p所占的空间大小/p所指的数组空间的大小，结果为1.
官方答案：sizeof(x)表示10个int型所占的内存空间的总和；
         sizeof(*x)表示int所占的内存空间；
	 sizeof(x)/sizeof(*x)可以理解为数组x所占的全部空间除以其中一个元素所占的空间；
	 sizeof(p)表示指针所占的空间大小；
	 sizeof(*p)的运算对象*p时指针p所指的对象，即int变量x，所以求值结果是int值所占的空间大小；
	 
ex4_30

(a)的含义是先求变量x所占空间的大小，然后与变量y的值相加，因为sizeof的优先级高于一元正号的优先级，所以如果想求表达式x+y所占的内存空间，应写成：sizeof(x+y);
(b)的含义是先定位到指针p所指的对象，然后求该对象中名字为mem的数组成员第i个元素的尺寸。因为成员选择运算符的优先级高于sizeof的优先级，所以可以不用加括号，如果真的想加括号，则写成：sizeof(p ->mem[i]);
(c)的含义是先求变量a在内存中所占的空间大小，再把求得的值与变量b的值进行比较。因为sizeof的优先级高于比较运算符，所以如果想求表达式a<b所占的内存空间，应写成：sizeof（a<b）;
(d)的含义是求函数f（）返回值所占内存空间的大小，因为函数调用的优先级远远高于sizeof的优先级，所以不用加括号。


ex4_31

前置运算符用的是改变后的对象，后置运算符用的是改变之前对象的副本，这是前置版本和后置递版本的区别。本题中，因为递增递减运算符与真正使用这两个变量的语句位于不同的表达式中，所以不会有什么影响。（ix++、cnt--和ivec[ix]=cnt不在一个表达式中）

ex4_32

这段程序首先定义了一个定义了一个常量size，让它的值为5，然后定义了一个大小为5的数组ia，接下来用for循环：第一部分定义整形指针指向数组ia的首元素，并且定义了一个整数ix，并给它赋初值为0;第二部分判断循环的终止条件，当ix没有达到size同时指针ptr没有指向数组最后一个元素的下一位置时，执行循环体；第三部分令变量ix和指针ptr分别执行递增操作。

ex4_33

根据优先级表可以知道，条件运算符的优先级低于递增/递减运算符，但高于逗号运算符（逗号运算符是所有运算符中优先级最低的），所以原表达式等价于:(someValue?++x,++y:--x),--y,求值过程是先判断someValue是否为真，如果为真，则依次执行x和y的递增操作，最后执行--y，如果someValue为假，则执行--x和--y的操作。

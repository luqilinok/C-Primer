ex4_1

该表达式的运算结果是105.

ex4_2

(a)*（vec.begin()） (b)(*(vec.begin()))+1

ex4_3

正如题目所说，C++只规定了非常少的二元运算符（逻辑与运算符、逻辑或运算符、逗号运算符）的求值顺序，其他绝大多数二元运算符的求值顺序并没有明确规定，尽管这种方法可能会引发潜在的风险，但是仍然是可以接受的：因为我们只要注意两点：（1）在拿不准的时候主动用括号来强制让表达式的组合关系符合程序的逻辑要求；（2）一旦改变了某个运算对象的值，在表达式的其他地方就不要再用这个运算对象了（当改变对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效）。当注意这两点以后，就可以发挥出提高代码生成效率的优势，降低风险。

ex4_4

（（12/3）*4）+（5*15）+(（24%4）/2)=91;

ex4_5

(a).-(30*3)+(21/5)=-86;
(b).-30+((3*21)/5)=-18;
(c).((30/3)*21)%5=0;
(d).((-30/3)*21)%4=-2.

ex4_6

假设该整数名为num，则表达式num%2==0为真是偶数，该表达式为假时num是奇数。

ex4_7

溢出是一种常见的算术运算错误，因为在计算机中存储某种类型的内存空间有限，所以该类型的表示能力（范围）也是有限的，当计算的结果值超出这个范围时，就会产生未定义的数值，这种错误称为溢出。

假定编译器规定int占32位，则下面3条表达式将产生溢出错误：
int i =2147483647+1;
int j=-100000*300000;
int k=2015*2015*2015*2015.

 ex4_8
 
 逻辑与运算符的求值顺序是从左向右的，左右两侧的运算结果必须都为真则逻辑与表达式的结果为真，左侧运算对象结果无法确定表达式的结果时才会计算右侧表达式的运算结果，
 逻辑或运算符的求值顺序也是从左向右的，左右两侧的运算结果有一个为真则逻辑或表达式的结果为真，当且仅当左侧运算结果为假时才计算右侧运算对象的结果。
 相等运算符的两个运算结果都需要求值，C++没有规定其求值顺序。

ex4_9

首先这段代码定义了一个常量字符指针cp，并为其赋值为：Hello World，条件语句if的意思是：先检查指针cp是否有效，如果cp为空指针或者是无效的指针，则条件不满足。如果cp有效，即cp指向了内存中某个有效地址，继续解引用指针cp，并检查cp所指的对象是否为空字符'\0',如果cp所指对象不是空字符则条件满足，否则不满足。
   在本例中，初始状态下cp指向了字符串的首字符，是有效的；同时当前cp所指的对象时字符'H',不是空字符，所以if的条件部分为真。


ex4_10

int i;
	while (cin>>i&&i!=42)
 
ex4_11

a>b&&b>c&&c>d

ex4_12

i!=j<k的含义如下：
  因为C++规定<、<=、>、>=的优先级高于==和!=。所以上式的结果等同于i!=(j<k),即先比较j和k的大小，得到的结果是一个布尔值(1或0)；然后判断i的值与之是否相等。


ex4_13

(a)的表达式经过赋值后i的结果为3，d的结果也是3；（b）的表达式的结果经过赋值后的表达式的结果i是3，d经过强制类型转换后的结果也是3.


ex4_14

第一条if语句将报错，因为字符型数值是右值；第二条if语句从语法上来说没有错误，但容易引起歧义，应该改成if(i==42)

ex4_15
下面的赋值当然是非法:首先dval是双精度浮点数，ival是整形，pi是指向int类型的指针，三个变量的类型是不一样的，所以不能放在一起赋值，如果想要消除编译错误，应该进行如下的修改: 

double dval, int ival int *pi;
dval=ival=0;
pi=o;

ex4_16

(a)的原意是把getPtr()得到的指针赋值给p，然后判断p是否是一个空指针，但是上述表达式不会按照这个意思来进行运行，因为赋值运算符的优先级特别低，所以会先执行不相等运算符，再去执行赋值运算符，这样就与原意相违背了，修改的方法是将getPtr()整体加上括号：if((getPtr())!=0);
(b)的原意是判断i的值是否是1024，但是此题中的表达式是将1024赋值给i，所以错了，应该进行如下的修改：if(i==1024)

标准库string的输入运算符自动忽略字符串开头的空白（包括空格符、换行符、制表符登），从第一个真正的字符开始读起，直到遇到下一处空白为止。
如果希望在最终的字符串汇总保留输入时的空白符，应该使用getline函数代替原来的>>运算符，getline从给定的输入流中读入数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串中。

ex3_7

本题中如果将auto换成char并不会对结果造成影响，因为auto的作用是推断结果的类型，本题中auto推断的结果正是char型的内容，所以不会对结果产生影响。

ex3_8

在本题中，我们希望处理字符串的每一个字符，且无需在意字符串的处理顺序，因此与传统的while循环和for循环相比，使用范围for循环更直观简洁。

ex3_9

本题代码的作用是输出字符串s的首字符，但是这段代码是不合法的，因为这段代码没有给字符串s赋初值，字符串为空，所以不存在下标为0的首字符。

ex3_11

该程序段从语法上来说是合法的，s是一个常量字符串，则c的推断类型就是常量引用，即c所绑定的对象值是不能改变的。

ex3_12

a是正确的，定义了一个名为ivec的vector对象，其中每个元素都是vector<int>对象；
b是错误的，svec的类型是string，而ivec的元素类型是int型，因此不能使用ivec初始化svec；
c是正确的，定义了一个名为svec的vector对象，其中包含10个元素，每个元素都是字符串null；

ex3_13

a中的vector包含了一个元素，元素数量为0；
b包含了10个元素，每个元素都被初始化为0；
c的元素数量是10个，每个元素都被初始化为42；
d的元素数量为1，元素的初始化值为10；
e的元素数量为2，分别初始化为10，42；
f的元素数量为10，每一个元素都被初始化为空串；
g的元素数量为10，每一个元素都被初始化为“hi”

ex3_18

这段程序是非法的，因为ivec不存在任何元素，因此ivec[0]的形式是非法的，程序试图访问的对象根本就不存在，要想要vector对象中添加新元素，需要使用push_back函数。

ex3_19

(1)先定义一个空vector对象，然后添加元素：
vector<int> vInt;
for(int i=0;i<10;i++)
  vInt.push_back(42);
  
(2)列表初始化，罗列出全部10个元素的值。
vector<int> vInt={42,42,42,42,42,42,42,42,42,42};
(3)用括号给出所有元素的值
vector<int> vInt={42,42,42,42,42,42,42,42,42,42};
(4) 定义的时候使用参数指定元素个数及重复的值
vector<int> vInt{10,42};
(5)先指定元素个数，再利用范围for循环依次为元素赋值
vector<int> vInt{10};
for(auto &i:vInt)
{
  i=42;
 }
 方法(4) 的初始化方式最为简介直观，当vector对象的元素个数较多且取值重复时，这是一个很好的choice，思路1在开始的时候不限定元素的个数，比较灵活。
  
ex3_26

    C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。
    与之相反，C++定义了两个迭代器的减法运算，两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一个容器中的元素或尾后元素。
    另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中的左右移动。
    在本题中，因为迭代器的加法不存在，所以mid=（beg+end）/2;不合法，mid=beg+（end-beg）/2的含义是：先计算end-beg的值得到容器中的元素个数，然后控制迭代器从开始处向右移动二分之一容器的船度，从而定位到容器正中间的元素。

ex3_27

(a)是非法的，buf_size是一个普通的无符号数，不是常亮，不能作为数组的维度；
(b)是合法的，因为4*7-14=14是一个常量表达式。
(c)是非法的，txt_size()是一个普通的函数调用，没有被定义为constexpr，不能作为数组的维度。
(d)是非法的额，当使用字符串初始化数组时，默认在尾部添加一个空字符'\0',算上这个空字符该字符串共有12个字符，但是字符数组的维度只有11，无法容纳题目中的字符串。

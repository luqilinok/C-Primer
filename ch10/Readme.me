ex10_04

根据书中所讲，accumulate蕴含着一个编程假定，将元素类型加到和的类型上是可行的，即序列中元素的类型必须与第三个参数相匹配或者是能够转换为第三个参数的类型；
本题中如果v是vector<double>类型的话，就错了，因为accumulate(v.cbegin(),v.cend(),0)表明和是整形的，所以如果v是vector<double>的情况下，accumulate函数会自动将double类型转换成int类型；
如果想要避免这种情况发生，应该将本题中accumulate函数的第三个参数换成0.0

ex10_05

根据P109页的定义可以知道，C风格字符串的比较实际上是将两个char*（字符串指针）进行比较，而非字符串本身进行比较，又因为equal要求比较的两个元素能够用“==”来比较两个类型即可，因此C风格的字符串进行比较是没有意义的。

ex10_06

(a)是错误的:泛型算法不会执行容器操作，即永远不会添加或删除元素，copy算法要求目标序列至少要包含与原序列一样多的元素，在本题中，vec是空的，所以无法执行copy操作，所以如果想要确保由足够元素空间的方法是使用插入迭代器，将push_back操作改为back_inserter(vec)即可，具体参考ex10_07_a.cpp
(b)是错误的：reserve函数的目的是为vec分配了至少能够容纳10个int的内存空间，但是正如叔公关键概念中所说的那样：如果一些算法从两个序列中读取元素，构成这两个序列的元素可以来自于不同类型的容器；而且，两个序列中元素的类型也不要求严格匹配，要求的是能够比较两个序列中的元素，即算法比较的是fill_n中的元素，此时vec中的元素仍然是空的，所以无法使用fill_n函数，应该利用back_inserter(vec)中添加元素，具体参考ex10_07_b.cpp

ex10_08

泛型算法不知道“容器”这个概念，只接受迭代器参数，运行于这些迭代器之上，通过迭代器来访问元素
因此，当传递给算法普通迭代器时，迭代器只能顺序或随机访问容器中的元素，造成的效果就是算法只能读取元素，改变元素值，移动元素，但无法添加或删除元素；
但是当传递插入迭代器时，这个迭代器可以完成插入元素的操作
因此，标准库算法不直接操作容器，只操作迭代器，从而间接访问迭代器，能不能插入和删除元素，不在于算法，而在于传递给它们的迭代器是否具有这样的能力


ex10_10

算法不改变容器大小的原因是为了让一个算法用于多种不同的数据类型，实现算法与所操作的数据结构的分离，这样可以更好的提升编程效率，算法访问数据的唯一通道就是迭代器，是否改变容器大小，是迭代器的责任

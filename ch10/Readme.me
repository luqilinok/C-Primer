ex10_04

根据书中所讲，accumulate蕴含着一个编程假定，将元素类型加到和的类型上是可行的，即序列中元素的类型必须与第三个参数相匹配或者是能够转换为第三个参数的类型；
本题中如果v是vector<double>类型的话，就错了，因为accumulate(v.cbegin(),v.cend(),0)表明和是整形的，所以如果v是vector<double>的情况下，accumulate函数会自动将double类型转换成int类型；
如果想要避免这种情况发生，应该将本题中accumulate函数的第三个参数换成0.0

ex10_05

根据P109页的定义可以知道，C风格字符串的比较实际上是将两个char*（字符串指针）进行比较，而非字符串本身进行比较，又因为equal要求比较的两个元素能够用“==”来比较两个类型即可，因此C风格的字符串进行比较是没有意义的。

ex10_06

(a)是错误的:泛型算法不会执行容器操作，即永远不会添加或删除元素，copy算法要求目标序列至少要包含与原序列一样多的元素，在本题中，vec是空的，所以无法执行copy操作，所以如果想要确保由足够元素空间的方法是使用插入迭代器，将push_back操作改为back_inserter(vec)即可，具体参考ex10_07_a.cpp
(b)是错误的：reserve函数的目的是为vec分配了至少能够容纳10个int的内存空间，但是正如叔公关键概念中所说的那样：如果一些算法从两个序列中读取元素，构成这两个序列的元素可以来自于不同类型的容器；而且，两个序列中元素的类型也不要求严格匹配，要求的是能够比较两个序列中的元素，即算法比较的是fill_n中的元素，此时vec中的元素仍然是空的，所以无法使用fill_n函数，应该利用back_inserter(vec)中添加元素，具体参考ex10_07_b.cpp

ex10_08

泛型算法不知道“容器”这个概念，只接受迭代器参数，运行于这些迭代器之上，通过迭代器来访问元素
因此，当传递给算法普通迭代器时，迭代器只能顺序或随机访问容器中的元素，造成的效果就是算法只能读取元素，改变元素值，移动元素，但无法添加或删除元素；
但是当传递插入迭代器时，这个迭代器可以完成插入元素的操作
因此，标准库算法不直接操作容器，只操作迭代器，从而间接访问迭代器，能不能插入和删除元素，不在于算法，而在于传递给它们的迭代器是否具有这样的能力


ex10_10

算法不改变容器大小的原因是为了让一个算法用于多种不同的数据类型，实现算法与所操作的数据结构的分离，这样可以更好的提升编程效率，算法访问数据的唯一通道就是迭代器，是否改变容器大小，是迭代器的责任

ex10_23

bind是可变参数的，它接受的第一个参数是一个可调用对象，即实际工作函数A，返回供算法使用的新的可调用对象B。若A接受x个参数，则bind的参数个数应该是x+1，即除了A之外，其他参数一一对应A所接受的参数，这些参数有一部分是来自于B(_n),另外一些来自于所处函数的局部变量

ex10_26

三种插入迭代器的差别在于如何向容器中插入元素：
back_inserter调用push_back;front_inserter调用push_front;inserter插入到给定位置（作为inserter的第二个参数传递给它）之前

ex10_38

86.输入迭代器：可以读取序列中的元素，支持：
	• 用于比较两个迭代器的相等和不相等运算符（== 、!=）
	• 用于推进迭代器的潜质和后置递增运算（++）
	• 用于读取元素的解引用运算符（*）          //解引用运算符只会出现在赋值运算符的右侧
	• 箭头运算符（->）等价于(*it).member    //解引用迭代器并提取对象的成员
输入迭代器只用于顺序访问，只能用于单遍扫描算法
87.输出迭代器：只写而不读元素，支持：
	• 用于推进迭代器的前置和后置递增运算（++）
	• 解引用运算符(*)        //只会出现在赋值运算符的左侧
输出迭代器只能用于单遍扫描算法，用作目的位置的迭代器通常都是输出迭代器
88.前项迭代器：可以读写元素，只在序列中沿着一个方向移动
89.前项迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素
90.使用前项迭代器的算法可以对序列进行多遍扫描
91.双向迭代器：可以正向/反向读写序列中的元素
除了支持所有前项迭代器的操作之外，双向迭代器还支持前置和后置递减运算符(--)
92.除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器
93.随机访问迭代器：提供在常量时间内访问序列中任意元素的能力，支持：
	• 用于比较两个迭代器相对位置的关系运算符(<、<=、>和>=)
	• 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整个元素后的位置
	• 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离
  	•下标运算符（iter[n]）,与*(iter[n])等价

ex10_39

list是双向迭代器，可读可写，多遍扫描，支持递增递减操作；vector迭代器是随机访问迭代器

ex10_40

copy要求前两个参数至少是输入迭代器，表示一个输入范围，它读取这个范围中的元素，写入到第三个参数表示的输出序列中，因此第三个参数至少是输出迭代器
reserve要反向处理序列，因此要求两个参数至少是双向迭代器
unique顺序扫描元素，覆盖重复元素，要求两个参数至少是前项迭代器

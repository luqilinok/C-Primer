ex15_01

虚成员就是虚函数，虚函数就是在类中被声明为virtual的成员，基类希望这种成员在派生类中重定义，除了构造函数之外，任意非static成员都可以为虚函数

ex15_02

protected受保护的成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问，而private即使是其派生类也不能访问


ex15_04

(a)是错误的，不能用类本身作为类的基类
(b)是正确的
(c)声明类时，不可以包含派生列表

ex15_08

静态类型：表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；
动态类型：动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知

ex15_09

基类的静态类型可能和其动态类型是不一致的，例子如下：
    Bulk_quote bulk;
    Quote *pQuote=&bulk;
    Quote &rQuote=bulk;
    double print_total(ostream &os,const Quote &otem,size_t n);
    
ex15_10

ifstream是从istream中派生而来的，是一个对象，所以能够正常使用

ex15_12

override：在C++11标准中，可以使用override关键字来说明派生类中的虚函数，这么做的好处可以更加清晰的告诉编译器我们想要覆盖掉原来已存在的虚函数，如果定义了一个函数与基类中的名字相同但是形参列表不同，在不适用override关键字时这种函数的定义是合法的，在使用了override关键字之后，这种行为是非法的，编译器会报错
final：如果我们将某个函数定义成final，则不允许后续的派生类覆盖这个函数，否则会报错
因此同时将一个成员函数声明成override和final能够让我们的意图更加清晰

ex15_13

成员函数的函数体中避免虚函数的问题，因为这会导致函数的自我调用，导致无限循环，此处派生类的print()函数中使用的print()函数会自动被解析为对自身的调用。所以应加上作用域限定符,具体例子请看ex15_13


ex15_14

(a)bobj.print();用的是基类的print函数
(b)dobj.print();用的是派生类的print函数
(c)bp1->name();用的是基类的name函数
(d)bp2->name();用的是派生类中基类的name函数
(e)br1.print();用的是基类的print函数
(f)br2.print();用的是派生类的print函数

ex15_17

错误信息显示：不能实例化抽象类

ex15_18

只有d1和dd1才能够赋值，这是因为：只有当派生类公有地继承基类时，用户代码才能使用派生类向基类的转换；也就是说，如果派生类继承基类的方式是受保护的或者私有的，则用户代码不能使用该转换
    本题中，只有d1和dd1类是公有的继承基类，故只有它们才能完成向基类的转换

ex15_19

Derived_from_Private:private Priv_Derv这个类的函数是不合法的，原因如下：
1.无论派生类以什么方式继承基类，派生类的成员函数和友元函数都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和函数来说永远都是可访问的
2.如果派生类继承基类的方式是公有的或者受保护的，则派生类的成员和友元可以使用派生类向基类的类型转换，反之，如果派生类继承基类的方式是私有的，则不能使用

ex12_01

StrBlob的data成员是一个指向string的vector的shared_ptr，因此StrBlob的赋值不会拷贝vector的内容，而是多个StrBlob对象共享一个（创建于动态内存空间上）的vector对象
代码第3行创建b2时提供了3个string的列表，因此会创建一个包含3个string的vector对象，并创建一个shared_ptr指向此对象（引用计数为1）
第4行将b2赋予b1时，创建一个shared_ptr也指向刚才创建的vector对象，引用计数变为2
因此，第4行向b2添加一个string时，会向两个StrBlob共享的vector中添加此string，最终，在代码结尾，b1和b2均包含4个string

ex12_03

push_back和pop_back的含义是向StrBlob对象共享的vector对象添加元素或从中删除元素，因此，不应该为其重载const版本，因为常量StrBlob对象不能够进行修改，也就不能够进行添加和删除操作

ex12_04

check函数是一个私有成员函数，即它只被StrBlob的成员函数调用，不会被用户程序所调用，又因为data_size的成员类型是size_type,这是一个无符号类型，不会产生负数，因此在定义的check函数中，不需要检查i是否大于0

ex12_05

explicit的作用是阻止构造函数进行的隐式转换，所以如果没有编写一个initializer_list explicit，那么StrBlob可以进行隐式转换，即在需要StrBlob的地方可以使用列表进行替代，而且，可以进行拷贝形式的初始化，这令编写程序更为简单
但是这种隐式转换并不总是好的，因为列表中可能并非都是合法的值，另一方面，对于接受StrBlob的函数，传递给它一个列表，会创建一个临时的StrBlob对象，对其进行列表初始化，，然后将其传递给函数，当函数完成后，此对象被丢弃，再也无法访问了，对于这些情况，我们可以定义显式的构造函数，禁止隐式类类型转换

ex12_08

按照这段程序执行的话，p将会被转变成一个bool类型的值，这意味着一个动态内存在分配后无法释放了，会造成内存泄漏

ex12_09

这段代码很好的展示了智能指针在管理内存上的优点：
对于普通指针部分，首先分配了两个int型对象，指针分别保存在p和r中，接下来，将指针q的值赋予了r，这会带来两个严重的问题：
  1.首先是一个直接的内存泄漏问题，r和q一样都指向42的内存地址，而r中原来保存的地址--100的内存没有指针来进行管理了，变成了“孤儿内存”，从而造成了内存泄漏；
  2.其次是一个“空悬指针”的问题，由于r和q指向同一个动态对象，如果程序编写不当，会产生释放了其中一个指针，而继续使用另一个指针的问题，继续使用的指针指向的是一块已经释放的内存，是一个空悬指针，继续读写它指向的内存可能导致程序崩溃甚至系统崩溃的严重问题。
  使用shared_ptr则可以很好地解决这些问题，首先，分配了两个共享的对象，分别由共享指针p2和q2指向，因此它们的引用计数都是1，接下来，将q2赋值给r2，赋值操作会将q2指向的对象地址赋予r2，这样r2被赋予了新值，因此r2的引用计数减1，将q2拷贝给r2，因此q2的的引用计数加1，这样，前者的引用计数变为0，占用的内存空间就会被释放，不会造成内存的泄漏，而后者的引用计数变为2，也不会因为r2和q2之一的销毁就释放它的内存空间，因此也不会造成空悬指针的问题
